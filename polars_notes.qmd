---
title: "Polars notes"
format: html
editor: source
toc: true
toc-depth: 6
toc-location: right
fontsize: small #small, medium, large, 1.2em, 12px, ...
execute:
  echo: true #whether to include code block
  eval: false #whether to run code
  warning: false #include warnings
  error: false #include errors
  output: false #include output
  # include: false #catch all for  preventing any results (code + results)
---



### Load package and data

:::::::::::::: {.columns}
::: {.column width="49%"}
```{r}
library(tidyverse)
DIAMONDSr <- diamonds
BAND_MEMBERSr <- band_members
BAND_INSTRUMENTS_r <- band_instruments
```
:::
::: {.column width="2%"}
<!-- empty column to create gap -->
:::
::: {.column width="49%"}
```{python}
import polars as pl
DIAMONDSp = pl.from_pandas(r.DIAMONDSr)
BAND_MEMBERS_p = pl.from_pandas(r.BAND_MEMBERSr)
BAND_INSTRUMENTSp = pl.from_pandas(r.BAND_INSTRUMENTS_r)
```
:::
::::::::::::::


###### Generate a data frame from scratch

:::::::::::::: {.columns}
::: {.column width="49%"}
```{r}
tibble(
  id=1:3,
  color=c("blue","red","green"),
  size=c("small","medium","large")
)
```
:::
::: {.column width="2%"}
<!-- empty column to create gap -->
:::
::: {.column width="49%"}
```{python}
pl.DataFrame(
  {
    'id': [1, 2, 3],
    'color': ['blue', 'red', 'green'],
    'size': ['small', 'medium', 'large']
  }
).to_pandas()
```
:::
::::::::::::::






###### Extract vector

:::::::::::::: {.columns}
::: {.column width="49%"}
```{r}
DIAMONDSr$color #method 1
DIAMONDSr[["color"]] #method 2
DIAMONDSr %>% pull(color) #method 3
```
:::
::: {.column width="2%"}
<!-- empty column to create gap -->
:::
::: {.column width="49%"}
```{python}
DIAMONDSp['color'] #method 1
DIAMONDSp.get_column('color') #method 2
```
:::
::::::::::::::






### Table Characteristics

:::::::::::::: {.columns}
::: {.column width="49%"}
```{r}
nrow(DIAMONDSr) #height
ncol(DIAMONDSr) #width
dim(DIAMONDSr) #height and width
map(DIAMONDSr,class) #list of classes
glimpse(DIAMONDSr) #column datatypes
```
:::
::: {.column width="2%"}
<!-- empty column to create gap -->
:::
::: {.column width="49%"}
```{python}
DIAMONDSp.height #height
DIAMONDSp.width #width
DIAMONDSp.shape #height and width (tuple)
DIAMONDSp.columns #column names (list)
DIAMONDSp.dtypes #datatypes (list)
DIAMONDSp.schema #column datatypes (dict)
```
:::
::::::::::::::



### Row/Column Filtering

###### Extract top 3 rows

:::::::::::::: {.columns}
::: {.column width="49%"}
```{r}
DIAMONDSr[1:3,] #method 1
head(DIAMONDSr,3) #method 2
DIAMONDSr %>% slice(1:3) #method 3
```
:::
::: {.column width="2%"}
<!-- empty column to create gap -->
:::
::: {.column width="49%"}
```{python}
DIAMONDSp[[1,2,3],:].to_pandas()
DIAMONDSp.head(3).to_pandas()
```
:::
::::::::::::::


###### Multiple row filter criteria

:::::::::::::: {.columns}
::: {.column width="49%"}
```{r}
DIAMONDSr %>% 
  filter(clarity=="VVS1",
         price>2000,
         grepl("[DEF]",color))
```
:::
::: {.column width="2%"}
<!-- empty column to create gap -->
:::
::: {.column width="49%"}
```{python}
(DIAMONDSp
  .filter(
    (pl.col('clarity')=='VVS1') &
    (pl.col('price') > 2000) & 
    (pl.col('color').cast(pl.Utf8).str.contains('[DEF]'))
  )
).to_pandas()
```
:::
::::::::::::::









### Select/Rename columns


###### Routine select

:::::::::::::: {.columns}
::: {.column width="49%"}
```{r}
DIAMONDSr %>% select(carat,cut,clarity)
```
:::
::: {.column width="2%"}
<!-- empty column to create gap -->
:::
::: {.column width="49%"}
```{python}
(DIAMONDSp
  .select(['carat','cut','clarity'])
).to_pandas()
```
:::
::::::::::::::



###### Select columns using regex pattern

:::::::::::::: {.columns}
::: {.column width="49%"}
```{r}
DIAMONDSr %>% select(matches("^c"))
```
:::
::: {.column width="2%"}
<!-- empty column to create gap -->
:::
::: {.column width="49%"}
```{python}
(DIAMONDSp
  .select([
    pl.col('^c.*$')  
  ])
).to_pandas()
```
:::
::::::::::::::



###### Select columns of a certain type

:::::::::::::: {.columns}
::: {.column width="49%"}
```{r}
DIAMONDSr %>% select(where(is.factor))
```
:::
::: {.column width="2%"}
<!-- empty column to create gap -->
:::
::: {.column width="49%"}
```{python}
(DIAMONDSp
  .select([
    pl.col(pl.Categorical)  
  ])
).to_pandas()


```
:::
::::::::::::::





###### Select all columns _except_ those specified

:::::::::::::: {.columns}
::: {.column width="49%"}
```{r}
DIAMONDSr %>% select(-c(x,y,z))
```
:::
::: {.column width="2%"}
<!-- empty column to create gap -->
:::
::: {.column width="49%"}
```{python}
(DIAMONDSp
  .select([
    pl.all().exclude(['x','y','z'])
  ])
).to_pandas()
```
:::
::::::::::::::



###### Select columns and rename

:::::::::::::: {.columns}
::: {.column width="49%"}
```{r}
DIAMONDSr %>% select(price_usd=price,length=x,width=y,depth=z)
```
:::
::: {.column width="2%"}
<!-- empty column to create gap -->
:::
::: {.column width="49%"}
```{python}
(DIAMONDSp
  .select([
    pl.col('price').alias('price_usd'),
    pl.col('x').alias('length'),
    pl.col('y').alias('width'),
    pl.col('z').alias('depth')
  ])
).to_pandas()
```
:::
::::::::::::::



###### Select all columns and add prefix

:::::::::::::: {.columns}
::: {.column width="49%"}
```{r}
DIAMONDSr %>% rename_with(.fn=~paste0("var_",.))
```
:::
::: {.column width="2%"}
<!-- empty column to create gap -->
:::
::: {.column width="49%"}
```{python}
(DIAMONDSp
  .select([
    pl.all().prefix('var_')
  ])
).to_pandas()
```
:::
::::::::::::::




###### Select and programmatically rename

:::::::::::::: {.columns}
::: {.column width="49%"}
```{r}
varmap <- c("price_usd"="price",
            "length"="x",
            "width"="y",
            "depth"="z")
DIAMONDSr %>% select(!!!varmap)
```
:::
::: {.column width="2%"}
<!-- empty column to create gap -->
:::
::: {.column width="49%"}
```{python}
varmap = {'price':'price_usd',
          'x':'length',
          'y':'width',
          'z':'depthx'}
(DIAMONDSp
  .select(varmap)
  .rename(varmap)
).to_pandas()
```
:::
::::::::::::::



### Mutate/Transmute


###### Mutate

:::::::::::::: {.columns}
::: {.column width="49%"}
```{r}
DIAMONDSr %>%
  mutate(price_thousands=price*1000,
         log_price=log(price),
         xyz=paste(x,y,z,sep="+"))
```
:::
::: {.column width="2%"}
<!-- empty column to create gap -->
:::
::: {.column width="49%"}
```{python}
(DIAMONDSp
  .with_columns([
    (pl.col('price')*1000).alias('price_thousands'),
    pl.col('price').log().alias('log_price'),
    pl.concat_str([pl.col('x'),pl.col('y'),pl.col('z')],sep='+').alias('xyz')
  ])
).to_pandas()
```
:::
::::::::::::::


###### Transmute

:::::::::::::: {.columns}
::: {.column width="49%"}
```{r}
DIAMONDSr %>%
  transmute(
    color_is_DEF=color %in% c("D","E","F"),
    color_status=case_when(
      color=="J" ~ "very poor",
      color %in% c("H","I") ~ "poor",
      color %in% c("F","G") ~ "ok",
      TRUE ~ "excellent"
    ),
    clarity=str_to_title(clarity))
```
:::
::: {.column width="2%"}
<!-- empty column to create gap -->
:::
::: {.column width="49%"}
```{python}
(DIAMONDSp
  .select([
    pl.col('color').cast(pl.Utf8).is_in(['D','E','F']).alias('color_is_DEF'),
    pl.when(pl.col('color')=='J').then('very poor')
      .when(pl.col('color').cast(pl.Utf8).is_in(['H','I'])).then('poor')
      .when(pl.col('color').cast(pl.Utf8).is_in(['F','G'])).then('ok')
      .otherwise('excellent')
      .alias('color_status'),
    pl.col('clarity').apply(lambda s: s.title())
  ])
).to_pandas()
```
:::
::::::::::::::





### Group By and Summarize


###### Count rows by group

:::::::::::::: {.columns}
::: {.column width="49%"}
```{r}
DIAMONDSr %>% 
  group_by(cut,color) %>%
  summarize(n=n(),
            .groups="drop")

DIAMONDSr %>% count(cut,color) #shortcut
```
:::
::: {.column width="2%"}
<!-- empty column to create gap -->
:::
::: {.column width="49%"}
```{python}
(DIAMONDSp
  .groupby(['cut','color'])
  .agg([
    pl.count().alias('n')
  ])
).to_pandas()
```
:::
::::::::::::::

###### Calculate various summaries by group

:::::::::::::: {.columns}
::: {.column width="49%"}
```{r}
DIAMONDSr %>%
  group_by(cut) %>%
  summarize(n=n(),
            mean_price=mean(price),
            max_price=max(price),
            available_colors=paste(sort(unique(color)),collapse=", "),
            .groups="drop")
```
:::
::: {.column width="2%"}
<!-- empty column to create gap -->
:::
::: {.column width="49%"}
```{python}
(DIAMONDSp
  .groupby('cut')
  .agg([
    pl.count().alias('n'),
    pl.col('price').mean().alias('mean_price'),
    pl.col('price').max().alias('max_price'),
    pl.col('color').unique().cast(pl.Utf8).sort().str.concat(', ').alias('availble_colors')
  ])
).to_pandas()
```
:::
::::::::::::::


###### Select first row after sorting, by group

:::::::::::::: {.columns}
::: {.column width="49%"}
```{r}
DIAMONDSr %>%
  group_by(cut) %>%
  arrange(desc(price),depth) %>%
  slice(1) %>%
  ungroup()
```
:::
::: {.column width="2%"}
<!-- empty column to create gap -->
:::
::: {.column width="49%"}
```{python}
(DIAMONDSp
  .sort(['price','depth'],reverse=[True,False])
  .groupby('cut')
  .head(1)
).to_pandas()
```
:::
::::::::::::::












### Apply to specific columns (across)

###### Apply to all columns

:::::::::::::: {.columns}
::: {.column width="49%"}
```{r}
DIAMONDSr %>% 
  mutate(across(.fns=~paste0(.,"_xyz")))
```
:::
::: {.column width="2%"}
<!-- empty column to create gap -->
:::
::: {.column width="49%"}
```{python}
(DIAMONDSp
  .with_columns([
    pl.all()+'_xyz'
  ])
).to_pandas()
```
:::
::::::::::::::




###### Apply to columns using regex

:::::::::::::: {.columns}
::: {.column width="49%"}
```{r}
DIAMONDSr %>% 
  transmute(across(.cols=matches("^c"),.fns=~paste0(.,"_x")))
```
:::
::: {.column width="2%"}
<!-- empty column to create gap -->
:::
::: {.column width="49%"}
```{python}
# (DIAMONDSp
#   .select([
#     pl.col('^c.*$') + '_x'
#   ])
# ).to_pandas()

(DIAMONDSp
  .select([
    pl.col('^c.*$')
  ])
).to_pandas()

```
:::
::::::::::::::



###### Apply to columns of a certain type

:::::::::::::: {.columns}
::: {.column width="49%"}
```{r}
DIAMONDSr %>% 
  mutate(across(.cols=where(is.numeric),
                .fns=~. * 1000))

```
:::
::: {.column width="2%"}
<!-- empty column to create gap -->
:::
::: {.column width="49%"}
```{python}
(DIAMONDSp
  .with_columns([
    pl.col([pl.Float64,pl.Int32]) * 1000
  ])
).to_pandas()
```
:::
::::::::::::::





### Joins



###### Left join
	
:::::::::::::: {.columns}
::: {.column width="49%"}
```{r}
BAND_MEMBERSr %>% left_join(BAND_INSTRUMENTS_r,by="name")
```
:::
::: {.column width="2%"}
<!-- empty column to create gap -->
:::
::: {.column width="49%"}
```{python}
(BAND_MEMBERS_p
  .join(BAND_INSTRUMENTSp,on='name',how='left')
).to_pandas()
```
:::
::::::::::::::



###### Inner join
	
:::::::::::::: {.columns}
::: {.column width="49%"}
```{r}
BAND_MEMBERSr %>% inner_join(BAND_INSTRUMENTS_r,by="name")
```
:::
::: {.column width="2%"}
<!-- empty column to create gap -->
:::
::: {.column width="49%"}
```{python}
(BAND_MEMBERS_p
  .join(BAND_INSTRUMENTSp,on='name',how='inner')
).to_pandas()
```
:::
::::::::::::::



###### Right join
	
:::::::::::::: {.columns}
::: {.column width="49%"}
```{r}
BAND_MEMBERSr %>% right_join(BAND_INSTRUMENTS_r,by="name")
```
:::
::: {.column width="2%"}
<!-- empty column to create gap -->
:::
::: {.column width="49%"}
```{python}
(BAND_MEMBERS_p
  .join(BAND_INSTRUMENTSp,on='name',how='right')
).to_pandas()
```
:::
::::::::::::::


###### Outer join
	
:::::::::::::: {.columns}
::: {.column width="49%"}
```{r}
BAND_MEMBERSr %>% full_join(BAND_INSTRUMENTS_r,by="name")
```
:::
::: {.column width="2%"}
<!-- empty column to create gap -->
:::
::: {.column width="49%"}
```{python}
(BAND_MEMBERS_p
  .join(BAND_INSTRUMENTSp,on='name',how='outer')
).to_pandas()
```
:::
::::::::::::::


###### Anti join
	
:::::::::::::: {.columns}
::: {.column width="49%"}
```{r}
BAND_MEMBERSr %>% anti_join(BAND_INSTRUMENTS_r,by="name")
```
:::
::: {.column width="2%"}
<!-- empty column to create gap -->
:::
::: {.column width="49%"}
```{python}
(BAND_MEMBERS_p
  .join(BAND_INSTRUMENTSp,on='name',how='anti')
).to_pandas()
```
:::
::::::::::::::

### Pivoting/Reshaping 

###### Pivot Longer

:::::::::::::: {.columns}
::: {.column width="49%"}
```{r}
diamonds
DIAMONDSr %>%
  pivot_longer(cols=c(x,y,z),names_to="axis",values_to="mm")
```
:::
::: {.column width="2%"}
<!-- empty column to create gap -->
:::
::: {.column width="49%"}
```{python}
(DIAMONDSp
  .melt(id_vars=list(set(DIAMONDSp.columns).difference(['x','y','z'])),variable_name='variable',value_name='value')
).to_pandas()
```
:::
::::::::::::::




###### Pivot Wider

:::::::::::::: {.columns}
::: {.column width="49%"}
```{r}
DIAMONDSr %>%
  pivot_wider(id_cols=clarity,names_from=cut,values_from=price,values_fn=mean)
```
:::
::: {.column width="2%"}
<!-- empty column to create gap -->
:::
::: {.column width="49%"}
```{python}
(DIAMONDSp
  .pivot(index='clarity',values='price',columns='cut',aggregate_fn='mean')
).to_pandas()
```
:::
::::::::::::::



### Nested columns

###### Split string column into nested list, unnest into long format

:::::::::::::: {.columns}
::: {.column width="49%"}
```{r}
DIAMONDSr %>%
  mutate(cut_word=str_split(cut," ")) %>%
  unnest(cut_word)
```
:::
::: {.column width="2%"}
<!-- empty column to create gap -->
:::
::: {.column width="49%"}
```{python}
(DIAMONDSp
  .with_columns([
    pl.col('cut').cast(pl.Utf8).str.split(' ').alias('cut_word'),
  ])
  .explode('cut_word')
).to_pandas()
```
:::
::::::::::::::





###### Move columns into single nested column, then unnest to individual columns again.

:::::::::::::: {.columns}
::: {.column width="49%"}
```{r}
DIAMONDSr %>%
  nest(col_color_clarity=c(cut,color,clarity)) %>%
  unnest(col_color_clarity)
```
:::
::: {.column width="2%"}
<!-- empty column to create gap -->
:::
::: {.column width="49%"}
```{python}
(DIAMONDSp
  .with_columns([
    pl.struct(pl.col(['cut','color','clarity'])).alias('cut_color_clarity')
  ])
  .drop(['cut','color','clarity'])
  .unnest('cut_color_clarity')
).to_pandas()
```
:::
::::::::::::::





###### Nested table in a single column, by group


:::::::::::::: {.columns}
::: {.column width="49%"}
```{r}
DIAMONDSr %>%
  group_by(color) %>%
  nest(group_info=-color) %>%
  ungroup()
```
:::
::: {.column width="2%"}
<!-- empty column to create gap -->
:::
::: {.column width="49%"}
```{python}
(DIAMONDSp
  .groupby('color')
  .agg([
    pl.struct(pl.all().exclude('color')).alias('group_info')
  ])
).to_pandas()
```
:::
::::::::::::::





<!-- ###### xxxx -->

<!-- :::::::::::::: {.columns} -->
<!-- ::: {.column width="49%"} -->
<!-- ```{r} -->
<!-- DIAMONDSr     # r code -->
<!-- ``` -->
<!-- ::: -->
<!-- ::: {.column width="2%"} -->
<!-- <!-- empty column to create gap --> -->
<!-- ::: -->
<!-- ::: {.column width="49%"} -->
<!-- ```{python} -->
<!-- DIAMONDSp.to_pandas()    # python -->
<!-- ``` -->
<!-- ::: -->
<!-- :::::::::::::: -->




<!-- ###### xxxx -->

<!-- :::::::::::::: {.columns} -->
<!-- ::: {.column width="49%"} -->
<!-- ```{r} -->
<!-- DIAMONDSr     # r code -->
<!-- ``` -->
<!-- ::: -->
<!-- ::: {.column width="2%"} -->
<!-- <!-- empty column to create gap --> -->
<!-- ::: -->
<!-- ::: {.column width="49%"} -->
<!-- ```{python} -->
<!-- DIAMONDSp.to_pandas()    # python -->
<!-- ``` -->
<!-- ::: -->
<!-- :::::::::::::: -->






<!-- ###### xxxx -->

<!-- :::::::::::::: {.columns} -->
<!-- ::: {.column width="49%"} -->
<!-- ```{r} -->
<!-- DIAMONDSr     # r code -->
<!-- ``` -->
<!-- ::: -->
<!-- ::: {.column width="2%"} -->
<!-- <!-- empty column to create gap --> -->
<!-- ::: -->
<!-- ::: {.column width="49%"} -->
<!-- ```{python} -->
<!-- DIAMONDSp.to_pandas()    # python -->
<!-- ``` -->
<!-- ::: -->
<!-- :::::::::::::: -->




<!-- ###### xxxx -->

<!-- :::::::::::::: {.columns} -->
<!-- ::: {.column width="49%"} -->
<!-- ```{r} -->
<!-- DIAMONDSr     # r code -->
<!-- ``` -->
<!-- ::: -->
<!-- ::: {.column width="2%"} -->
<!-- <!-- empty column to create gap --> -->
<!-- ::: -->
<!-- ::: {.column width="49%"} -->
<!-- ```{python} -->
<!-- DIAMONDSp.to_pandas()    # python -->
<!-- ``` -->
<!-- ::: -->
<!-- :::::::::::::: -->





